## 问题描述

## 测试样例

`样例1`:

```js
输入: n = 9, max = 34,
array = [6, 6, 6, 8, 8, 8, 5, 5, 1]

输出: [8, 5]

说明：
`array` 数组中可组成4个葫芦，
分别为
[6, 6, 6, 8, 8]
[6, 6, 6, 5, 5]
[8, 8, 8, 6, 6]
[8, 8, 8, 5, 5]

其中
[8, 8, 8, 6, 6]的牌面值为36,
大于34不符合要求。
剩下的3个葫芦的大小关系为
[8, 8, 8, 5, 5]
>
[6, 6, 6, 8, 8]
>
[6, 6, 6, 5, 5]

所以返回
[8, 5]
```

`样例2`：

```js
输入： n = 9, max = 34,
array = [9, 9, 9, 9, 6, 6, 6, 6, 13]

输出：[6, 9]

说明：
可组成2个葫芦，
分别为
[9, 9, 9, 6, 6]
和
[6, 6, 6, 9, 9]，

由于
[9, 9, 9, 6, 6]
的牌面值为
39，
大于
37,

所以返回
[6, 9]
```

`样例3`：

```js
输入：n = 9, max = 40,
array = [1, 11, 13, 12, 7, 8, 11, 5, 6]

输出：[0, 0]
说明： 无法组成任何葫芦，故返回[0，0]
```

`样例4`：

```js
输入：n = 6, max = 50,
array = [13, 13, 13, 1, 1, 1]

输出:
[1, 13]

说明：
可组成两个葫芦，分别为
[A, A, A, K, K]
和
[K, K, K, A, A]，

两者牌面值都小于50，
故都合法。

因为三张相同牌面值的
A > K，
故
[A, A, A, K, K]
比
[K, K, K, A, A]
要大，
返回
[1, 13]
```

回头来看看题目：

在一场经典的德州扑克游戏中，
有一种牌型叫做“葫芦”。

“葫芦”由五张牌组成，
其中包括三张相同牌面值的牌 a
和另外两张相同相同牌面值的牌 b。

如果两个人同时拥有“葫芦”，
我们会优先比较牌 a 的大小，

若牌 a 相同则再比较 牌 b 的大小，

牌面值的大小规则为:

1(A) > K > Q > J > 10 > 9 > ... > 2，

其中`1(A)`的牌面值为 1，
K为13，
依次类推。

在这个问题中，
我们对“葫芦”增加了一个限制：
组成“葫芦”的五张牌牌面值之和不能超过给定的最大值 max。

给定一组牌，你需要找到符合规则的最大的“葫芦”组合，
并输出其中三张相同的拍卖你和两张相同的牌面。
如果过涨不到符合条件的“葫芦”，
则输出"0, 0"。

---

```js
function solution(n, max, array) {
  // Edit your code here

  return [0, 0];
}

function main() {
  // Add your test cases here
  console.log(JSON.stringify(solution(9, 34, [6, 6, 6, 8, 8, 8, 5, 5, 1])) === JSON.stringify([5, 5]));
  console.log(JSON.stringify(solution(9, 37, [9, 9, 9, 9, 6, 6, 6, 6, 13])) === JSON.stringify([6, 9]));
  console.log(JSON.stringify(solution(9, 40, [1, 11, 13, 12, 7, 8, 11, 5, 6])) === JSON.stringify([0, 0]));
}

main();
```

1、3 a  2 b

2、5 total < max

3、如果有多组符合。
优先选 a 大的，

如果a相同，
则选 b 大的。

## 算法步骤

1、`统计牌面值的出现次数`：
遍历牌组，统计每个牌面值出现的次数。

2、`生成`所有可能的“葫芦”组合：

- 遍历统计结果，找3张同样的牌面值去进行组合。

- 找到了3张，那另外两张也要找同样的。


3、`筛选符合条件的葫芦`

- 算牌面的和，筛出不超过 max 的组合。

- 在符合条件的组合中，选择牌面值 a 最大的，
如果a相同，就找 b 最大的。

4、`返回结果`：

如果没有符合条件的“葫芦”，
返回`[0, 0]`。

## 总结

通过以上步骤，我们可以逐步筛选出符合条件的最大“葫芦”组合。
