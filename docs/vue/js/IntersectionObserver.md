Intersection Observer

来看三个效果。

第`一`个效果：

是一些`图片懒加载`的效果。
这些图片一开始是一个`默认图`片。
当你`滑过去`的时候，
它会`加载`出`真实`的`图片`。

第`二`个效果：

`加载更多`的效果。

瀑布流布局，就会加载一个小圈圈在转。
当滑过去的时候呢，
会加载更多啊，

这就是第二个效果，
加载更多的效果。


第`三`个效果：

是一个`广告`的效果。

这个广告在这里播放，
但是呢滑下去呢，
这个广告就会暂停。

必须要让用户完整地看到这个广告。
之后它才会继续播放。

---

这三个效果，
看上去是毫不相干。

但是呢实际上，
它们都是用到了同一个前端技术。

叫做`Intersection Observer`。

这是一套`API`。
应用这套`API`。
可以非常方便地去完成这三个效果。

这`API`是用来干嘛的呢。
它是用来`创建`一个`观察器`。

用于观察什么呢？
用于观察`某一个元素`。
跟`某一个东西`是否`有交叉`。

为什么`观察交叉`,
就可以实现这`3`个效果呢？

第一个效果里边，
观察的就是这些图片元素 跟 视口 有没有交叉，
一个元素跟视口有交叉了。
意味着用户就能看得见这些元素了。

那么能看得见的时候。
是不是就应该去加载这个元素图片了。
这是第一个效果。

---

第二效果，
是加载更多。
那其实我们就是去观察这个小圈圈。
跟这个视口有没有交叉。

有交叉了过后，
就表示这个小圈圈看得见了。

看得见的时候，
我就需要去加载更多。

这是第二个效果。

---

第三个效果。

其实我们就去观察这个广告的视频，
跟我们的视口的交叉情况。

交叉情况不满足的时候，
那么就可以让这个视频暂停。

利用这一套`API`。
就可以非常轻松地实现这三个效果。

那就比我们去监控什么滚动条的位置。
要轻松很多了。

因为我们去监控滚动条的时候呢。

一。
是这个滚动条呢。
它的事件会不断地触发。
影响效率。

第二个问题呢。
是这个滚动条呢。
我还要去计算它的一些滚动位置。
计算起来挺麻烦的。

而用这套`API`就会非常轻松地解决了。

一旦使用了这套API，
你会知道什么叫轻松和幸福。

咱一个个来做。
一边做一边来讲解这套`API`。

首先我们看第一个例子。
第一个例子是`图片懒加载`的效果。

那么如何来实现懒加载呢。
道理非常简单。
就是

```html
```

一开始啊，
我给这些图片啊，

给它设置一个默认的图片。
你看，全都是默认图片。

然后呢，
给它一个自定义属性`src`啊。
就是`data-src`,
给它一个真实的图片地址，

那么一开始这个图片呢，
肯定是显示的是默认图片对吧。
就是src里面的。

那么后续呢，
我只需要把这个真实的地址，
去替换掉它的`src`。
不就完事了吗？

对不对，
关键是什么时候进行替换。
那么这个时候，
我们就可以利用我们刚才说的这套`API`。

首先呢我们可以去创建这么一个观察器。
叫做`IntersectionObserver`。

```js
const ob = new IntersectionObserver();
```
然后呢得到这个观察器过后呢。
我们就可以进行观察了。

```js
const ob = new IntersectionObserver();
ob.observe(谁呢)
哦是dom，那是哪个dom呢
ob.observe(dom)
```
观察谁呢。
这里边要传入一个`dom`元素。
你传的是哪个`dom`元素。
那么就观察哪个`dom`元素。

那么，
我们这里要去观察哪些dom元素呢。

当然是要去观察那些带有`data-src`的图片。
对吧，
所以说我们这里呢。
首先拿到所谓的图片。

```js
const ob = new IntersectionObserver();

// 拿到图片dom，带有data-src的image
const imgs = document.querySelectorAll('img[data-src]');

// 然后呢，去循环这个图片
// 因为这个观察器呢，它是可以观察很多元素的，它可以不只观察一个元素。
imgs.forEach(img => {
  ob.observe(img);
})
// 循环图片去观察每一个图片。

// ob.observe(谁呢)
```

但是呢。
这里还有一些信息没有告诉它，
有哪些信息没有告诉它呢。

第一个信息就是我观察它了。
它的叫交叉情况呢，
也发生变化了。

那变化过后我要做啥呢，
对吧，
我们需要给它一个回调函数。

那么这个回调函数呢。

是写到这里的。

```js
// 回调函数
const ob = new IntersectionObserver(() => {
  console.log('交叉情况发生变化了，运行这个回调函数。')
});

// 拿到图片dom，带有data-src的image
const imgs = document.querySelectorAll('img[data-src]');

// 然后呢，去循环这个图片
// 因为这个观察器呢，它是可以观察很多元素的，它可以不只观察一个元素。
imgs.forEach(img => {
  ob.observe(img);
})
// 循环图片去观察每一个图片。

// ob.observe(谁呢)
```

但是完了没，还没完。
你光告诉它了回调函数还不够。
你还要告诉它这么三个东西。

哪三个东西呢。

需要通过第二个参数来进行配置。

```js
// 回调函数
const ob = new IntersectionObserver(() => {
  console.log('交叉情况发生变化了，运行这个回调函数。')
}, {
  // 第一个东西呢。是root。
  // root: null, // 就是观察的这个元素，跟谁在交叉。就是观察的这个元素的祖先元素。跟它的父元素交叉了呢。还是跟它的父元素的父元素交叉了呢。如果说这里填的是null的话，就表示说观察视口。就默认为视口啊。既然是默认为视口的话。第一个参数是可以不用配置的，因为它的默认值就是null。

  // 第二个东西呢。是rootMargin。
  // rootMargin: '0px', // 第二个参数叫做rootMargin，表示什么意思呢。需要给大家画张图哈。比方说我们现在观察的是某一个图片。和这个视口有没有交叉。这个rootMargin表示什么意思呢，表示基于这个视口啊，是否进行扩散和收缩。那比方说这个`rootMargin`，我给它写的是10个像素。那是啥意思呢。就表示说我对这个视口的范围内。我向外扩散10个像素。倒是观察的时候呢。就是观察这个元素跟这个Margin这个边缘有没有交叉。那如果写的是负数呢，那就是相当于往内收缩10个像素。那观察的是这个地方有没有交叉。这个值一般呢，我们没有去配置，没有配置的时候呢。它的默认值就是0.，0的时候就可以不用谢。

  // 第三个东西呢。是threshould。
  threshould: 0, // 表示观察的阈值。比如说这个阈值为0的时候是啥意思。就是你观察的那个元素跟视口之间。只要碰上了。那么就表示交叉情况发生变化了，它就需要运行那个回调函数，那么再进行过后呢，它就不需要再进行运行这个回调函数了。那入如果说将来再出来的时候，比方说从这里出来哈，退出来的时候到0这个位置。是不是又到达阈值了，那么到达阈值之后，是不是又需要去运行那个回调函数了。也就是说这样子呢。进去再出来，这个回调函数会运行两次，一次是进去到达阈值的时候，一次是出来的时候，到达阈值的时候。其他中间情况呢，是不再运行的。

  // 如果把这个阈值设置成1，取值范围是0到1，表达啥意思呢？
  // 那表示的是进去的时候，必须是完整进入过后，那么才能够到达阈值。
  // 那么这个时候呢。会运行回调。
  // 出来的时候也是一样，只要碰上了，到达阈值了，那么也会运行回调。其他情况不再运行回调。
  // 那么如果写的是0.5呢。那么就是这个元素到一半的时候，运行回调函数。所以呢，这里我们写多少呢。我就写0吧。因为我们希望这个图片只要碰到视口边缘，就表示这个图片就即将被用户看到了。
  // 那么这个时候就需要进行运行回调了。
});

// 拿到图片dom，带有data-src的image
const imgs = document.querySelectorAll('img[data-src]');

// 然后呢，去循环这个图片
// 因为这个观察器呢，它是可以观察很多元素的，它可以不只观察一个元素。
imgs.forEach(img => {
  ob.observe(img);
})
// 循环图片去观察每一个图片。

// ob.observe(谁呢)
```

我们来看一下，
一开始这个回调就进行了一次，
好像有点不对劲。

有四张图，
但是为什么只运行一次呢。
不应该运行4次吗？

它其实是这样的，
它会把这些情况呢，
全部合并在一起，运行一次回调。
就是它的一个优化手段。

那这种情况，
我怎么知道有哪些元素有交叉，
哪些元素没有交叉呢。
就是哪些元素到达了阈值，
哪些元素没有到达阈值，
我怎么知道呢。

它会通过一个函数来传递给你。

这个参数叫做`entries`。

entries是进入的意思，入口的意思。

```js
// 回调函数
const ob = new IntersectionObserver((entries) => {
  console.log('交叉情况发生变化了，运行这个回调函数。');
  // entries 实际上是一个数组。它实际上会把所有与的元素全部告诉你。打印看看。
  console.log(entries); // 所有的结果都打印给你看了。每个元素是一个对象，叫做`IntersectionObserverEntry`。这个对象里边呢，它就会有一些信息啊，其中有两个属性。
  // 其中有两个属性是非常关键的。一个属性叫做`isIntersecting`（是个布尔值，表示的意思就是说这个元素，它跟我们的视口到底有没有到达阈值，到达了就表示有交叉，它就会把它设为true，另一个属性就叫做target，就表示是哪个元素，这是个dom对象，交不交叉看这个isIntersecting），所以就可以通过这个属性来判断交叉没有。

  // 这里我们拿到所有的元素了是吧，我们就可以通过一个循环，去找到那些已经有交叉的元素，怎么来判断它有没有交叉呢，是不是可以通过里边的属性。
  for (const entry of entries) {
    if (entry.isIntersecting) {
      console.log('交叉了') // 一开始有4次，往后随着我们的滚动就越来越多的交叉了。
      // 做啥
      // 找到那个元素，然后呢把这个图片的src设置为它的自定义属性。
      const img = entry.target;
      img.src = img.dataset.src; // 把data-src里的值，设置给img的src。

      // 你看这些能够看到的图片。是不是就一步步加载出来了。
      // 那么这些呢，能看到的图片。它们都能够一步步加载出来。而且如果要为了考虑到效率的话，像那些已经加载出来的图片，就不需要去观察它了。
      // 来一个unobserve。

      ob.unobserve(img); // 通过这个函数去取消观察。以后就不需要观察它了。
    }
  }
}, {
  threshould: 0
});

// 拿到图片dom，带有data-src的image
const imgs = document.querySelectorAll('img[data-src]');

// 然后呢，去循环这个图片
// 因为这个观察器呢，它是可以观察很多元素的，它可以不只观察一个元素。
imgs.forEach(img => {
  ob.observe(img);
})
// 循环图片去观察每一个图片。

// ob.observe(谁呢)
```

---

上面是第一个例子。

第二个例子就更加简单了。

加载更多的效果。
其实也是一样的道理。
去创建一个观察器。

```js
async function loadMoreImages (number = 10) {
  isLoading = false;
}

loadMoreImages(30);

const ob = new IntersectionObserver((entries) => {
  const entry = entries[0] // 因为我们这里只观察它的第一个元素。
  // 如果它已经有交叉了，那我们就去加载更多的10张图
  if (entry.isINtersecting) {
    loadMoreImages(10); // 就完事了。
  }
}, {
  threshold: 0,
});
ob.observe(document.querySelector('.load-more')); // 那么它跟视口有交叉的情况下，就是能看见的情况下，给它设置一个阈值、
```

第三个例子。

是个广告。

```js
const vd = document.querySelector('video');

const ob = new IntersectionObserver((entries) => {
  const entry = entries[0]
  if (entry.isIntersecting) {
    vd.play();
  } else {
    vd.pause();
  }
}, {
  threshold: 1 // 必须完整看到这个广告, 我才给你播放
});

ob.observe(vd);
```

只要这个视频被遮住了一点点，都给它停了，
要完整看到这个视频广告，才给你播，

如果这样子太变态太没人性，
就可以调一下这个threshold这个值。
不要设为1，
可以设为0.6保存这样。

这样子呢，
一开始可以看到这个视频，
到这个视频的60%被遮盖之后，就给它暂停。不超过60%就给它播。

这就是整个的实现过程。都是利用这套api。可以让这个事情变得非常简单。